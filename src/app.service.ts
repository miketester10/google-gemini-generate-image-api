import {
  ContentListUnion,
  createPartFromUri,
  createUserContent,
  File,
  GenerateContentResponse,
  GoogleGenAI,
  Modality,
} from '@google/genai';
import { HttpService } from '@nestjs/axios';
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  Logger,
  OnModuleInit,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { catchError, map, Observable, throwError } from 'rxjs';
import {
  GoogleAiModelResponse,
  Model,
} from './interfaces/google-ai-models-response.interface';

@Injectable()
export class AppService implements OnModuleInit {
  private readonly logger = new Logger(AppService.name);
  private readonly api_key = <string>(
    this.configService.get('GOOGLE_AI_API_KEY')
  );
  private readonly google_models_api = <string>(
    this.configService.get('GOOGLE_AI_MODELS_API')
  );
  private readonly model = <string>this.configService.get('MODEL');
  private ai: GoogleGenAI;

  constructor(
    private readonly configService: ConfigService,
    private readonly httpService: HttpService,
  ) {}

  onModuleInit() {
    this.ai = new GoogleGenAI({
      apiKey: this.api_key,
    });
  }

  getGoogleAiModels(): Observable<Model[]> {
    const API = this.google_models_api + this.api_key;

    return this.httpService.get<GoogleAiModelResponse>(API).pipe(
      map((response) => response.data.models),
      catchError((error) => {
        this.logger.error(`Error fetching models: ${error}`);
        return throwError(
          () => new BadRequestException('Error fetching models'),
        );
      }),
    );
  }

  async generateImage(contents: ContentListUnion): Promise<Buffer> {
    let response: GenerateContentResponse;
    try {
      response = await this.ai.models.generateContent({
        model: this.model,
        contents: contents,
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
          // mediaResolution: MediaResolution.MEDIA_RESOLUTION_HIGH,
        },
      });
    } catch (error) {
      this.logger.error(
        `Error while generating image: ${(error as Error).message}`,
      );
      throw new InternalServerErrorException('Error while generating image.');
    }

    const parts = response.candidates?.[0].content?.parts;

    if (!parts) {
      this.logger.error(`No candidates returned by Google AI.`);
      throw new BadRequestException('No candidates returned by Google AI.');
    }

    let buffer: Buffer | undefined = undefined;

    for (const part of parts) {
      if (part.text) {
        this.logger.debug(`Text: ${part.text}`);
      } else if (part.inlineData?.data) {
        const imageBytes = part.inlineData.data;
        buffer = Buffer.from(imageBytes, 'base64');
        this.logger.debug(`Buffer created.`);
      }
    }

    if (!buffer) {
      this.logger.error(`No buffer created.`);
      throw new BadRequestException('No image generated by Google AI.');
    }
    return buffer;
  }

  async editImage(prompt: string, file: Express.Multer.File): Promise<Buffer> {
    const MAX_SIZE = 20 * 1024 * 1024; // 20MB in byte
    let fileUploaded: File;
    let contents: ContentListUnion;

    // Prepare the content parts
    if (file.size > MAX_SIZE) {
      this.logger.debug(
        `Uploading file to Google AI beacause the size of the image is greater than 20MB`,
      );
      try {
        fileUploaded = await this.ai.files.upload({
          file: new Blob([file.buffer as BufferSource], {
            type: file.mimetype,
          }),
          config: { mimeType: file.mimetype },
        });
      } catch (error) {
        this.logger.error(
          `Error while uploading file to Google AI: ${(error as Error).message}`,
        );
        throw new InternalServerErrorException(
          'Error while uploading file to Google AI.',
        );
      }

      contents = createUserContent([
        {
          text: prompt,
        },
        createPartFromUri(fileUploaded.uri!, fileUploaded.mimeType!),
      ]);
    } else {
      contents = [
        {
          text: prompt,
        },
        {
          inlineData: {
            mimeType: file.mimetype,
            data: file.buffer.toString('base64'),
          },
        },
      ];
    }

    return this.generateImage(contents);
  }
}
